// Importe as bibliotecas necessÃ¡rias
const venom = require('venom-bot');

// Crie um cliente do Venom
venom
  .create({
    session: 'Bot-Felipe',
  })
  .then((venombot) => startBot(venombot))
  .catch((error) => console.error(error));

// Mapeamento de estÃ¡gios para cada cliente
const stages = {};

// Mapeamento de inatividade para cada cliente
const inactiveTimeouts = {};

// FunÃ§Ã£o para iniciar o bot
function startBot(venombot) {
  // Configura o ouvinte de mensagens
  venombot.onMessage((message) => {
    // Verifica se a mensagem recebida Ã© de um cliente e nÃ£o foi enviada pelo prÃ³prio bot
    if (!message.isGroupMsg && message.body && message.fromMe === false) {
      // Verifica o estÃ¡gio atual do atendimento
      const stage = getStage(message.from);

      if (stage === 0) {
        // EstÃ¡gio 0: SaudaÃ§Ã£o inicial e opÃ§Ãµes de atendimento
        const response = `ðŸ‘‹ OlÃ¡! Seja bem-vindo ao atendimento da *VipTech*.\nPosso te ajudar? Selecione a opÃ§Ã£o para prosseguir:\n\n   1ï¸âƒ£ - CRIAR UM CHAMADO\n   2ï¸âƒ£ - OUTROS\n   0ï¸âƒ£ - FALAR COM ATENDENTE`;
        // Envia a mensagem de resposta
        venombot.sendText(message.from, response);

        // Atualiza o estÃ¡gio para o prÃ³ximo
        setStage(message.from, 1);
      } else if (stage === 1) {
        // EstÃ¡gio 1: CriaÃ§Ã£o de chamado
        if (message.body === '1') {
          // Cliente selecionou a opÃ§Ã£o de criar um chamado
          const response = `Por favor, informe o problema que vocÃª estÃ¡ enfrentando.`;

          // Envia a mensagem de resposta
          venombot.sendText(message.from, response);

          // Atualiza o estÃ¡gio para o prÃ³ximo
          setStage(message.from, 2);
        } else if (message.body === '0') {
          // Cliente selecionou a opÃ§Ã£o de falar com um atendente
          const response = `VocÃª serÃ¡ direcionado para um atendente em breve.`;

          // Envia a mensagem de resposta
          venombot.sendText(message.from, response);

          // Atualiza o estÃ¡gio para o prÃ³ximo
          setStage(message.from, 3);

          // Define um atraso de 60 minutos para o prÃ³ximo estÃ¡gio
          setTimeout(() => {
            setStage(message.from, 0);
          }, 60 * 60 * 1000);
        } else {
          // Cliente selecionou uma opÃ§Ã£o invÃ¡lida
          const response = `OpÃ§Ã£o invÃ¡lida. Por favor, selecione uma das opÃ§Ãµes fornecidas.`;

          // Envia a mensagem de resposta
          venombot.sendText(message.from, response);
        }
      } else if (stage === 2) {
        // EstÃ¡gio 2: ConfirmaÃ§Ã£o do problema
        // Aqui vocÃª pode implementar a lÃ³gica para lidar com a confirmaÃ§Ã£o do problema relatado pelo cliente
        // Por exemplo, vocÃª pode armazenar a mensagem em uma variÃ¡vel e perguntar ao cliente se a mensagem estÃ¡ correta antes de prosseguir com a criaÃ§Ã£o do chamado

        // Exemplo de cÃ³digo para confirmar a mensagem enviada pelo cliente
        const response = `VocÃª estÃ¡ relatando o seguinte problema:\n\n${message.body}\n\nPor favor, confirme se a mensagem estÃ¡ correta.`;

        // Envia a mensagem de resposta
        venombot.sendText(message.from, response);

        // Atualiza o estÃ¡gio para o prÃ³ximo
        setStage(message.from, 3);

        // Define um atraso de 60 minutos para o prÃ³ximo estÃ¡gio
        setTimeout(() => {
          setStage(message.from, 0);
        }, 60 * 60 * 1000);
      } else if (stage === 3) {
        // EstÃ¡gio 3: Falar com atendente
        // Aqui vocÃª pode implementar a lÃ³gica para direcionar a mensagem do cliente para um atendente real ou fornecer mais informaÃ§Ãµes sobre como entrar em contato com a equipe de suporte

        // Exemplo de cÃ³digo para direcionar a mensagem para um atendente
        const response = `Sua mensagem serÃ¡ encaminhada para um atendente. Em breve vocÃª receberÃ¡ um retorno.`;

        // Envia a mensagem de resposta
        venombot.sendText(message.from, response);

        // Define um atraso de 60 minutos para o prÃ³ximo estÃ¡gio
        setInactiveTimeout(message.from, 60 * 60 * 1000);
      }
    }
  });
}

// FunÃ§Ã£o para obter o estÃ¡gio atual do atendimento
function getStage(clientId) {
  // Retorna o estÃ¡gio atual do cliente ou 0 se nÃ£o estiver definido
  return stages[clientId] || 0;
}

// FunÃ§Ã£o para definir o estÃ¡gio do atendimento
function setStage(clientId, stage) {
  // Atualiza o estÃ¡gio do cliente
  stages[clientId] = stage;
}

// FunÃ§Ã£o para definir o tempo de inatividade do cliente
function setInactiveTimeout(clientId, timeout) {
  // Limpa o timeout de inatividade existente, se houver
  clearTimeout(inactiveTimeouts[clientId]);

  // Define um novo timeout de inatividade
  inactiveTimeouts[clientId] = setTimeout(() => {
    setStage(clientId, 0);
    clearTimeout(inactiveTimeouts[clientId]);
  }, timeout);
}
